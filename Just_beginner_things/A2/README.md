# Differences in 32-bit and 64-bit assembly
`install multilib package for cross architechture manipulation`

Since assembly calling conventions and pointers are different in 64 and 32
bit architecture we can't use the same assembly code for both.
- We require two different c codes since while compiling the c code in
64 bit environment the object file generated is not compatible with
object file generated by nasm (in case of 32).So each assembler
program has to be compiled differently ,for ease of convenience i
used two c files (q4_64.c , q4_32.c)
- The naming of registers is different in 32(prefix as e) and in 64(prefix
as r).Some of the registers functionality is also different in both
versions (difference in callee and caller saved registers)
For 32-eax,edx,ecx are caller saved registers and ebx,esi,edi are
callee saved registers.
For 64- rbp,rbx,r12,r13,r14,r15 are callee saved registers rest all
are caller saved.

Makefile contents
```
#makefile
all: q4_32.o q4a.o ans1 q4_64.o q4b.o ans2
q4_32.o:q4_32.asm
	nasm -f elf32 -o q4_32.o q4_32.asm

q4a.o:q4_32.c
	gcc -c -m32 q4_32.c -o q4a.o          // -m32 to compile in 32 bit mode

ans1:q4_32.o q4a.o
	gcc -m32 q4_32.o q4a.o -o ans1
	./ans1
	@echo

q4_64.o:q4_64.asm
	nasm -f elf64 -o q4_64.o q4_64.asm

q4b.o:q4_64.c
	gcc -c q4_64.c -o q4a.o

ans2:q4_64.o q4b.o
	gcc q4_64.o q4a.o -o ans2
	./ans2
	@echo
```
In 32 bit assembly accessing parameters in stack is the only way to access parameters but in 64
accessing parameters through stack is not possible thus default registers are used for
accessing.

- 32 bit assembly [code](Just_beginner_things/A2/q4_32.asm)
```
SECTION .text
	global _long_add32
       
_long_add32: 	
	push ebp
	mov ebp,esp
	mov edx,[ebp+8]
	mov eax,[ebp+12]
	add eax,edx
	mov edx,[ebp+16]
	add eax,edx
	mov edx,[ebp+20]
	add eax,edx
	mov esp,ebp
	pop ebp
	ret
```
- 64 bit assembly [code](Just_beginner_things/A2/q4_64.asm)
```
SECTION .text
	global _long_add64
  
_long_add64:
	mov rax,rdi
	add rax,rsi
	add rax,rcx
	add rax,rdx
	ret 
```

Below is the code(extended_add label) which I tried to change from 32 bit
to 64 by just replacing the register suffix ‘e’ by ‘r’ but i got to know that line
13 which is the way to restore stack pointer was not used .
The stack passing and calling local arguments was entirely different thus i
had to change the code to `_long_add64` and directly add the parameters as
they are passed by default in these registers.
```
_extended_add:
	sub rsp,16
	mov rdx,[rbp+16]
	mov rax,[rbp+24]
	add rax,rdx
	mov rdx,[rbp+32]
	add rax,rdx
	mov rdx,[rbp+40]
	add rax,rdx
	;mov rsp,rbp  ;line 13
	add rsp,16
	ret
```  

Thus, I conclude that changes from 32 bit were needed as not only calling
of the functions got changed but also many register functionalities were
changed as well.

### TRY YOURSELF
- Clone the repo navigate to folder called A2
- Open the folder in terminal and run `make`
